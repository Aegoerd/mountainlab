#!/usr/bin/env nodejs

var request=require('request');
var progress=require('request-progress');
var FormData=require('form-data');

function print_usage() {
	console.log ('Usage:');
	console.log ('mlcp /path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat /path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --move s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --remove s3://bucketname/path/to/file.dat --ticket=[ticket]');
	console.log ('mlcp --list s3://bucketname/path --ticket=[ticket]');
	return;
}

var server_url='https://mlcps.herokuapp.com';
//server_url='http://localhost:8012';

var CLP=new CLParams(process.argv);

if ('mlcps' in CLP.namedParameters)
	server_url=CLP.namedParameters['mlcps'];

var ticket=CLP.namedParameters['ticket']||'';

if ('list' in CLP.namedParameters) {
	var address=CLP.unnamedParameters[0]||'';
	if (!address) {
		print_usage();
		return;
	}
	do_list(address,function() {
	});
}
else if ('remove' in CLP.namedParameters) {
	var address=CLP.unnamedParameters[0]||'';
	if (!address) {
		print_usage();
		return;
	}
	do_remove(address,function() {
	});
}
else {
	var src_address=CLP.unnamedParameters[0]||'';
	var dst_address=CLP.unnamedParameters[1]||'';

	if ((!src_address)||(!dst_address)) {
		print_usage();
		return;
	}

	if ((dst_address.startsWith('s3://'))&&(!src_address.startsWith('s3://'))) {
		do_upload(src_address,dst_address,function() {
			process.exit(0); //do this because of request-progress waiting for next timeout
		});
	}
	else if ((src_address.startsWith('s3://'))&&(!dst_address.startsWith('s3://'))) {
		do_download(src_address,dst_address,function() {
			process.exit(0); //do this because of request-progress waiting for next timeout
		});
	}
	else if ((src_address.startsWith('s3://'))&&(dst_address.startsWith('s3://'))) {
		if ('move' in CLP.namedParameters) {
			do_copy_or_move('move',src_address,dst_address,function() {
			});
		}
		else {
			do_copy_or_move('copy',src_address,dst_address,function() {
			});
		}
	}
	else {
		print_usage();
		return;
	}
}

function do_list(address,cb) {
	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);

	var url0=server_url+'/api/list';
	var req={
		ticket:ticket,
		bucket:bucket,
		path:path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		for (var i in obj.files) {
			var size_str=format_file_size(obj.files[i].size);
			console.log (obj.files[i].name+' ('+size_str+')');
		}
		if (cb) cb();
	});
}

function do_copy_or_move(str,src_address,dst_address,cb) {
	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	var url0=server_url+'/api/'+str;
	var req={
		ticket:ticket,
		src_bucket:src_bucket,
		src_path:src_path,
		dst_bucket:dst_bucket,
		dst_path:dst_path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		if (str=='copy') console.log ('Copied.');
		else if (str=='move') console.log ('Moved.');
		if (cb) cb();
	});
}

function do_remove(address,cb) {
	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);

	var url0=server_url+'/api/remove';
	var req={
		ticket:ticket,
		bucket:bucket,
		path:path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		console.log ('Removed.');
	});
}

function do_upload(src_address,dst_address,cb) {
	if (!file_exists(src_address)) {
		console.log ('Source file does not exist: '+src_address);
		return;
	}
	var src_size_bytes=file_size_bytes(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	var req={
		ticket:ticket,
		file_size:src_size_bytes,
		dst_bucket:dst_bucket,
		dst_path:dst_path
	};

	create_upload_request(req,function(tmp) {
		if (!tmp.success) {
			console.log ('Error making upload request: '+tmp.error);
			return;
		}

		var url=tmp.url;
		var query=tmp.query;

		var form = new FormData();
		for (var field in query) {
			form.append(field,query[field]);
		}
		console.log ('uploading: '+src_address+' to '+dst_address);
		form.append('file', require('fs').createReadStream(src_address));

		var timer=new Date();
		var done=false;
		var reqreq=form.submit(url, function(err, resp){
			if (err) {
				console.error('Error submitting upload: '+err.message);
				if (cb) cb({success:false,error:err.message}); cb=0;
			} else {
				var body='';
				resp.on('data',function(data) {
					body+=data.toString('utf-8');
				});
				resp.on('error',function(err) {
					console.log ('Error: '+err.message);
					if (cb) cb({success:false,error:err.message}); cb=0;
				});
				resp.on('end',function() {
					console.log (body);
					if (cb) {
						show_progress();
						cb({success:true}); cb=0;
					}
				});
				//console.log('body: '+JSON.stringify(body));
			}
		});
		function show_progress() {	
			if (reqreq.connection) {
				var uploaded=reqreq.connection._bytesDispatched;
				var mb_uploaded=Math.floor(uploaded/(1024*1024)*1000)/1000;
				var pct=Math.floor(uploaded/src_size_bytes*100);
				var elapsed_sec=(new Date()-timer)/1000;
				var rate=uploaded/elapsed_sec;
				rate=Math.floor(rate/(1024*1024)*1000)/1000;
				console.log ('Uploaded '+mb_uploaded+' MB ('+pct+'%) : '+rate+' MB/sec');
			}
			if (cb) setTimeout(show_progress,2000);
		}
		if (cb) setTimeout(show_progress,500);
	});

	function create_upload_request(req,callback) {
		var url0=server_url+'/api/create_upload_request';

		http_post_json(url0,req,{},function(tmp) {
			if (!tmp.success) {
				callback(tmp);
				return;
			}
			callback(tmp.object);
		});
	}
}

function do_download(src_address,dst_address,callback) {
	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);

	var req={
		ticket:ticket,
		src_bucket:src_bucket,
		src_path:src_path
	};

	create_download_request(req,function(tmp) {
		if (!tmp.success) {
			console.log ('Error making download request: '+tmp.error);
			if (callback) callback();
			return;
		}

		var url=tmp.url;
		

		download_with_progress(url,dst_address,function(tmp2) {
			if (callback) callback();
			return;
		});
	});

	function create_download_request(req,callback) {
		var url0=server_url+'/api/create_download_request';

		http_post_json(url0,req,{},function(tmp) {
			if (!tmp.success) {
				callback(tmp);
				return;
			}
			callback(tmp.object);
		});
	}
}


function download_with_progress(url,dst_path,callback) {
	var timer=new Date();
	// The options argument is optional so you can omit it 
	progress(request(url), {
	    throttle: 1000,                    // Throttle the progress event to 2000ms, defaults to 1000ms 
	    delay: 500                       // Only start to emit after 1000ms delay, defaults to 0ms 
	    // lengthHeader: 'x-transfer-length'  // Length header to use, defaults to content-length 
	})
	.on('progress', function (state) {
	    // The state is an object that looks like this: 
	    // { 
	    //     percent: 0.5,               // Overall percent (between 0 to 1) 
	    //     speed: 554732,              // The download speed in bytes/sec 
	    //     size: { 
	    //         total: 90044871,        // The total payload size in bytes 
	    //         transferred: 27610959   // The transferred payload size in bytes 
	    //     }, 
	    //     time: { 
	    //         elapsed: 36.235,        // The total elapsed seconds since the start (3 decimals) 
	    //         remaining: 81.403       // The remaining seconds to finish (3 decimals) 
	    //     } 
	    // } 
	    console.log (Math.floor(state.size.transferred/(1024*1024)*1000)/1000+' MB ('+Math.floor(state.percent*100)+'%) : '+Math.floor(state.speed/(1024*1024)*1000)/1000+' MB/sec'+' : '+(state.time.remaining||'unknown')+' sec remaining');
	})
	.on('error', function (err) {
		console.log ('Error downloading file: '+err.message);
	    callback({success:false,error:err.message});
	})
	.on('end', function () {
		var size0=file_size_bytes(dst_path);
		var elapsed_sec=Math.floor((new Date())-timer)/1000;
		var rate=size0/elapsed_sec/(1024*1024);
		console.log ('Downloaded '+Math.floor(size0/(1024*1024)*1000)/1000+' MB in '+elapsed_sec+' sec ('+Math.floor(rate*1000)/1000+' MB/sec)');
	    callback({success:true});
	})
	.pipe(require('fs').createWriteStream(dst_path));
}

function get_bucket_from_s3_address(str) {
	var list=str.split('/');
	return list[2]||'';
}

function get_path_from_s3_address(str) {
	var list=str.split('/');
	return list.slice(3).join('/');
}

function http_post_json(url,data,headers,callback) {
	var post_data=JSON.stringify(data);

	var url_parts=require('url').parse(url);

	var options={
		method: "POST",
		hostname: url_parts.hostname,
		port:url_parts.port,
		path:url_parts.path
	};

	var http_module;
	if (url_parts.protocol=='https:')
		http_module=require('https');
	else if (url_parts.protocol=='http:')
		http_module=require('http');
	else {
		if (callback)
			callback({success:false,error:'invalid protocol for url: '+url});
		return;
	}

	if (headers) {
		options.headers=headers;
	}

	var req=http_module.request(options,handler);
	req.on('error',function(e) {
		if (callback) callback({success:false,error:'Error in post request: '+e});
		callback=null;
	});
	function handler(res) {
		var txt='';
		res.on('data', (d) => {
			txt+=d
		});
		req.on('error', (e) => {
		  if (callback) callback({success:false,error:'Error in post: '+e});
		  callback=null;
		});
		res.on('end', function() {
			var obj;
			try {
				obj=JSON.parse(txt);
			}
			catch(err) {
				if (callback) callback({success:false,error:'Error parsing json response'});
				callback=null;
				return;
			}
			if (callback) callback({success:true,object:obj});
			callback=null;
		});
	}
	req.write(post_data);
	req.end();
}


function file_exists(path) {
	return require('fs').existsSync(path);
}

function file_size_bytes(path) {
	var stat=require('fs').statSync(path);
	return stat.size;
}


function CLParams(argv) {
	this.unnamedParameters=[];
	this.namedParameters={};

	var args=argv.slice(2);
	for (var i=0; i<args.length; i++) {
		var arg0=args[i];
		if (arg0.indexOf('--')===0) {
			arg0=arg0.slice(2);
			var ind=arg0.indexOf('=');
			if (ind>=0) {
				this.namedParameters[arg0.slice(0,ind)]=arg0.slice(ind+1);
			}
			else {
				//this.namedParameters[arg0]=args[i+1]||'';
				//i++;
				this.namedParameters[arg0]='';
			}
		}
		else if (arg0.indexOf('-')===0) {
			arg0=arg0.slice(1);
			this.namedParameters[arg0]='';
		}
		else {
			this.unnamedParameters.push(arg0);
		}
	}
};

function format_file_size(size_bytes) {
	size_bytes=Number(size_bytes);
	if (size_bytes>10e9) {
	  return Math.floor(size_bytes/1e9)+' GB';
	}
	else if (size_bytes>1e9) {
	  return Math.floor(size_bytes/1e8)/10+' GB';  
	}
	else if (size_bytes>10e6) {
	  return Math.floor(size_bytes/1e6)+' MB';
	}
	else if (size_bytes>1e6) {
	  return Math.floor(size_bytes/1e5)/10+' MB';  
	}
	else if (size_bytes>10e3) {
	  return Math.floor(size_bytes/1e3)+' KB';
	}
	else if (size_bytes>1e3) {
	  return Math.floor(size_bytes/1e2)/10+' KB';  
	}
	else {
	  return size_bytes+' bytes';
	}
}
