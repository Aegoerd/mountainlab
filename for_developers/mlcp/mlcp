#!/usr/bin/env nodejs

var request=require('request');
var progress=require('request-progress');
var FormData=require('form-data');

function print_usage() {
	console.log ('Usage:');
	console.log ('mlcp /path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat /path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --move s3://bucketname/path/to/src.dat s3://bucketname/path/to/dst.dat --ticket=[ticket]');
	console.log ('mlcp --remove s3://bucketname/path/to/file.dat --ticket=[ticket]');
	console.log ('mlcp --list s3://bucketname/path --ticket=[ticket]');
	return;
}

var server_url='https://mlcps.herokuapp.com';
//server_url='http://localhost:8012';

var CLP=new CLParams(process.argv);

if ('mlcps' in CLP.namedParameters)
	server_url=CLP.namedParameters['mlcps'];

var ticket=CLP.namedParameters['ticket']||'';

if ('list' in CLP.namedParameters) {
	var address=CLP.unnamedParameters[0]||'';
	if (!address) {
		print_usage();
		return;
	}
	do_list(address,function() {
	});
}
else if ('remove' in CLP.namedParameters) {
	var address=CLP.unnamedParameters[0]||'';
	if (!address) {
		print_usage();
		return;
	}
	do_remove(address,function() {
	});
}
else {
	var src_address=CLP.unnamedParameters[0]||'';
	var dst_address=CLP.unnamedParameters[1]||'';

	if ((!src_address)||(!dst_address)) {
		print_usage();
		return;
	}

	if ((dst_address.startsWith('s3://'))&&(!src_address.startsWith('s3://'))) {
		do_upload(src_address,dst_address,function() {
			process.exit(0); //do this because of request-progress waiting for next timeout
		});
	}
	else if ((src_address.startsWith('s3://'))&&(!dst_address.startsWith('s3://'))) {
		do_download(src_address,dst_address,function() {
			process.exit(0); //do this because of request-progress waiting for next timeout
		});
	}
	else if ((src_address.startsWith('s3://'))&&(dst_address.startsWith('s3://'))) {
		if ('move' in CLP.namedParameters) {
			do_copy_or_move('move',src_address,dst_address,function() {
			});
		}
		else {
			do_copy_or_move('copy',src_address,dst_address,function() {
			});
		}
	}
	else {
		print_usage();
		return;
	}
}

function do_list(address,cb) {
	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);

	var url0=server_url+'/api/list';
	var req={
		ticket:ticket,
		bucket:bucket,
		path:path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		for (var i in obj.files) {
			var size_str=format_file_size(obj.files[i].size);
			console.log (obj.files[i].name+' ('+size_str+')');
		}
		if (cb) cb();
	});
}

function do_copy_or_move(str,src_address,dst_address,cb) {
	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	var url0=server_url+'/api/'+str;
	var req={
		ticket:ticket,
		src_bucket:src_bucket,
		src_path:src_path,
		dst_bucket:dst_bucket,
		dst_path:dst_path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		if (str=='copy') console.log ('Copied.');
		else if (str=='move') console.log ('Moved.');
		if (cb) cb();
	});
}

function do_remove(address,cb) {
	var bucket=get_bucket_from_s3_address(address);
	var path=get_path_from_s3_address(address);

	var url0=server_url+'/api/remove';
	var req={
		ticket:ticket,
		bucket:bucket,
		path:path
	}

	http_post_json(url0,req,{},function(tmp) {
		if (!tmp.success) {
			console.error('Error in request: '+tmp.error);
			if (cb) cb();
			return;
		}
		var obj=tmp.object;
		if (!obj.success) {
			console.error('Error: '+obj.error);
			if (cb) cb();
			return;	
		}
		console.log ('Removed.');
	});
}

function do_upload(src_address,dst_address,cb) {
	if (!file_exists(src_address)) {
		console.log ('Source file does not exist: '+src_address);
		return;
	}
	var src_size_bytes=file_size_bytes(src_address);
	var dst_bucket=get_bucket_from_s3_address(dst_address);
	var dst_path=get_path_from_s3_address(dst_address);

	var req={
		ticket:ticket,
		file_size:src_size_bytes,
		dst_bucket:dst_bucket,
		dst_path:dst_path
	};

	var timer=new Date();
	var reqreqs=[];

	create_upload_request(req,function(tmp) {
		if (!tmp.success) {
			console.log ('Error making upload request: '+tmp.error);
			return;
		}

		if (tmp.parts) {
			var parts=tmp.parts;
			var num_parts=parts.length;
			var part_size=Math.ceil(src_size_bytes/num_parts);

			foreach(parts,{num_parallel:4},function(i,part,partcb) {
				var range=[i*part_size,(i+1)*part_size-1];
				if (range[1]>=src_size_bytes) range[1]=src_size_bytes-1;
				var reqreq0=perform_single_upload(part.url,part.query,src_address,range,function(aa) {
					if (!aa.success) {
						if (cb) cb(aa); cb=0;
						return;
					}
					partcb();
				});
				reqreqs.push(reqreq0);
			},function() {
				var summary_info={num_parts:num_parts,total_size:src_size_bytes};
				upload_part_summary_file(tmp.url,tmp.query,summary_info,function(bb) {
					if (!bb.success) {
						if (cb) cb(bb); cb=0;
						return;
					}
					if (cb) cb({success:true}); cb=0;
				});
			});

			/*
			for (var i=0; i<num_parts; i++) {
				var range=[i*part_size,(i+1)*part_size-1];
				if (range[1]>=src_size_bytes) range[1]=src_size_bytes-1;
				var reqreq0=perform_single_upload(parts[i].url,parts[i].query,src_address,range,function(aa) {
					if (!aa.success) {
						if (cb) cb(aa); cb=0;
						return;
					}
					num_parts_finished++;
				});
				reqreqs.push(reqreq0);
			}
			*/
		}
		else {
			var url=tmp.url;
			var query=tmp.query;
			var range=[0,src_size_bytes-1];
			var reqreq0=perform_single_upload(url,query,src_address,range,function(tmp2) {
				if (cb) cb(tmp2); cb=0;
			});
			reqreqs.push(reqreq0);
		}
	});

	function create_upload_request(req,callback) {
		var url0=server_url+'/api/create_upload_request';

		http_post_json(url0,req,{},function(tmp) {
			if (!tmp.success) {
				callback(tmp);
				return;
			}
			callback(tmp.object);
		});
	}

	function show_progress() {
		var uploaded=0;
		for (var ii in reqreqs) {
			var reqreq=reqreqs[ii];
			if (reqreq.connection)
				uploaded+=reqreq.connection._bytesDispatched;
		}
		var mb_uploaded=Math.floor(uploaded/(1024*1024)*1000)/1000;
		var pct=Math.floor(uploaded/src_size_bytes*100);
		var elapsed_sec=(new Date()-timer)/1000;
		var rate=uploaded/elapsed_sec;
		rate=Math.floor(rate/(1024*1024)*1000)/1000;
		console.log ('Uploaded '+mb_uploaded+' MB ('+pct+'%) : '+rate+' MB/sec');
		if (cb) setTimeout(show_progress,2000);
	}
	if (cb) setTimeout(show_progress,500);
}

function perform_single_upload(url,query,src_address,range,cb) {
	size_bytes=range[1]-range[0]+1;

	var form = new FormData();
	for (var field in query) {
		form.append(field,query[field]);
	}
	console.log ('uploading: '+src_address+' to '+dst_address);
	form.append('file', require('fs').createReadStream(src_address,{start:range[0],end:range[1]}));

	var done=false;
	var reqreq=form.submit(url, function(err, resp){
		if (err) {
			console.error('Error submitting upload: '+err.message);
			if (cb) cb({success:false,error:err.message}); cb=0;
		} else {
			var body='';
			resp.on('data',function(data) {
				body+=data.toString('utf-8');
			});
			resp.on('error',function(err) {
				console.log ('Error: '+err.message);
				if (cb) cb({success:false,error:err.message}); cb=0;
			});
			resp.on('end',function() {
				if (body.trim()) console.log (body);
				if (cb) {
					cb({success:true}); cb=0;
				}
			});
			//console.log('body: '+JSON.stringify(body));
		}
	});
	return reqreq;
}

function upload_part_summary_file(url,query,summary_info,cb) {
	var form = new FormData();
	for (var field in query) {
		form.append(field,query[field]);
	}
	form.append('file', JSON.stringify(summary_info));

	var done=false;
	console.log ('Uploading part summary file');
	form.submit(url, function(err, resp){
		if (err) {
			console.error('Error submitting summary file upload: '+err.message);
			if (cb) cb({success:false,error:err.message}); cb=0;
		} else {
			var body='';
			resp.on('data',function(data) {
				body+=data.toString('utf-8');
			});
			resp.on('error',function(err) {
				console.log ('Error: '+err.message);
				if (cb) cb({success:false,error:err.message}); cb=0;
			});
			resp.on('end',function() {
				if (body.trim()) console.log (body);
				if (cb) {
					cb({success:true}); cb=0;
				}
			});
		}
	});
}

function do_download(src_address,dst_address,callback) {
	var src_bucket=get_bucket_from_s3_address(src_address);
	var src_path=get_path_from_s3_address(src_address);

	var req={
		ticket:ticket,
		src_bucket:src_bucket,
		src_path:src_path
	};

	create_download_request(req,function(tmp) {
		if (!tmp.success) {
			console.log ('Error making download request: '+tmp.error);
			if (callback) callback();
			return;
		}

		if (tmp.parts) {
			download_parts_with_progress(tmp.parts,dst_address,tmp.size_bytes,function(tmp2) {
				if (callback) callback();
				return;
			});	
		}
		else {
			download_with_progress(tmp.url,dst_address,function(tmp2) {
				if (callback) callback();
				return;
			});
		}		
	});

	function create_download_request(req,callback) {
		var url0=server_url+'/api/create_download_request';

		http_post_json(url0,req,{},function(tmp) {
			if (!tmp.success) {
				callback(tmp);
				return;
			}
			callback(tmp.object);
		});
	}
}


function download_with_progress(url,dst_path,callback) {
	var timer=new Date();
	// The options argument is optional so you can omit it 
	progress(request(url), {
	    throttle: 1000,                    // Throttle the progress event to 2000ms, defaults to 1000ms 
	    delay: 500                       // Only start to emit after 1000ms delay, defaults to 0ms 
	    // lengthHeader: 'x-transfer-length'  // Length header to use, defaults to content-length 
	})
	.on('progress', function (state) {
	    // The state is an object that looks like this: 
	    // { 
	    //     percent: 0.5,               // Overall percent (between 0 to 1) 
	    //     speed: 554732,              // The download speed in bytes/sec 
	    //     size: { 
	    //         total: 90044871,        // The total payload size in bytes 
	    //         transferred: 27610959   // The transferred payload size in bytes 
	    //     }, 
	    //     time: { 
	    //         elapsed: 36.235,        // The total elapsed seconds since the start (3 decimals) 
	    //         remaining: 81.403       // The remaining seconds to finish (3 decimals) 
	    //     } 
	    // } 
	    console.log (Math.floor(state.size.transferred/(1024*1024)*1000)/1000+' MB ('+Math.floor(state.percent*100)+'%) : '+Math.floor(state.speed/(1024*1024)*1000)/1000+' MB/sec'+' : '+(state.time.remaining||'unknown')+' sec remaining');
	})
	.on('error', function (err) {
		console.log ('Error downloading file: '+err.message);
	    callback({success:false,error:err.message});
	})
	.on('end', function () {
		var size0=file_size_bytes(dst_path);
		var elapsed_sec=Math.floor((new Date())-timer)/1000;
		var rate=size0/elapsed_sec/(1024*1024);
		console.log ('Downloaded '+Math.floor(size0/(1024*1024)*1000)/1000+' MB in '+elapsed_sec+' sec ('+Math.floor(rate*1000)/1000+' MB/sec)');
	    callback({success:true});
	})
	.pipe(require('fs').createWriteStream(dst_path));
}

function download_parts_with_progress(parts,dst_path,src_size_bytes,callback) {
	mkdir_if_needed(dst_path+'.parts_');
	remove_parts_files(dst_path+'.parts_');
	var timer=new Date();
	var size0=0;
	var bytes_downloaded=[];
	for (var aa=0; aa<parts.length; aa++) bytes_downloaded.push(0);
	var num_parallel=4;
	foreach(parts,{num_parallel:num_parallel},function(ipart,part,part_cb){
		if (!callback) return; //signals we are done
		var dst_path_part=dst_path+'.parts_/part.'+(ipart+1);
		progress(request(part.url), {throttle: 1000*num_parallel, delay: 1000*(ipart % num_parallel)})
			.on('progress', function (state) {
				bytes_downloaded[ipart]=Number(state.size.transferred);
				var total_bytes_downloaded=0;
				for (var aa=0; aa<parts.length; aa++) total_bytes_downloaded+=bytes_downloaded[aa];
				var mb_downloaded=Math.floor(total_bytes_downloaded/(1024*1024)*1000)/1000;
				var pct=Math.floor(total_bytes_downloaded/src_size_bytes*100);
				var elapsed_sec=(new Date()-timer)/1000;
				var rate=total_bytes_downloaded/elapsed_sec;
				rate=Math.floor(rate/(1024*1024)*1000)/1000;
				console.log ('Downloaded '+mb_downloaded+' MB ('+pct+'%) : '+rate+' MB/sec');
			})
			.on('error', function (err) {
				console.log ('Error downloading file: '+err.message);
		    	if (callback) callback({success:false,error:err.message}); callback=0;
			})
			.on('end', function () {
				size0+=file_size_bytes(dst_path_part);
		    	part_cb();
			})
			.pipe(require('fs').createWriteStream(dst_path_part));

	},function() {
		var elapsed_sec=Math.floor((new Date())-timer)/1000;
		var rate=size0/elapsed_sec/(1024*1024);
		console.log ('Downloaded '+Math.floor(size0/(1024*1024)*1000)/1000+' MB in '+elapsed_sec+' sec ('+Math.floor(rate*1000)/1000+' MB/sec)');
		console.log ('Concatenating...');
		concatenate_parts(dst_path,function(tmp) {
			if (!tmp.success) {
				console.error('Error: '+tmp.error);
			}
			remove_parts_files(dst_path+'.parts_');
			require('fs').rmdirSync(dst_path+'.parts_');
			if (callback) callback(tmp); callback=0;
		});
		
	});
}

function concatenate_parts(dst_path,callback) {
	var fs=require('fs');
	if (fs.existsSync(dst_path))
		fs.unlinkSync(dst_path);
	var parts_dirname=dst_path+'.parts_';
	var files=[];
	var i=0;
	while (fs.existsSync(parts_dirname+'/part.'+(i+1))) {
		files.push(parts_dirname+'/part.'+(i+1));
		i++;
	}
	var out_stream=require('fs').createWriteStream(dst_path);
	out_stream.on('error', function (err) {
    	if (callback) callback({success:false,error:'Error writing to: '+dst_path}); callback=0;
  	});
	foreach(files,{num_parallel:1},function(ii,file,cb) {
		if (!callback) return;
		var in_stream=require('fs').createReadStream(file);
		in_stream.on('error',function(err) {
			if (callback) callback({success:false,error:'Error reading from: '+file}); callback=0;
		});
		in_stream.on('end',function() {
			cb();
		});
		in_stream.pipe(out_stream,{end:false});
	},function() {
		out_stream.end();
		if (callback) callback({success:true}); callback=0;
	});
}

function get_bucket_from_s3_address(str) {
	var list=str.split('/');
	return list[2]||'';
}

function get_path_from_s3_address(str) {
	var list=str.split('/');
	return list.slice(3).join('/');
}

function http_post_json(url,data,headers,callback) {
	var post_data=JSON.stringify(data);

	var url_parts=require('url').parse(url);

	var options={
		method: "POST",
		hostname: url_parts.hostname,
		port:url_parts.port,
		path:url_parts.path
	};

	var http_module;
	if (url_parts.protocol=='https:')
		http_module=require('https');
	else if (url_parts.protocol=='http:')
		http_module=require('http');
	else {
		if (callback)
			callback({success:false,error:'invalid protocol for url: '+url});
		return;
	}

	if (headers) {
		options.headers=headers;
	}

	var req=http_module.request(options,handler);
	req.on('error',function(e) {
		if (callback) callback({success:false,error:'Error in post request: '+e});
		callback=null;
	});
	function handler(res) {
		var txt='';
		res.on('data', function(d) {
			txt+=d
		});
		req.on('error', function(e) {
		  if (callback) callback({success:false,error:'Error in post: '+e});
		  callback=null;
		});
		res.on('end', function() {
			var obj;
			try {
				obj=JSON.parse(txt);
			}
			catch(err) {
				if (callback) callback({success:false,error:'Error parsing json response'});
				callback=null;
				return;
			}
			if (callback) callback({success:true,object:obj});
			callback=null;
		});
	}
	req.write(post_data);
	req.end();
}


function file_exists(path) {
	return require('fs').existsSync(path);
}

function file_size_bytes(path) {
	var stat=require('fs').statSync(path);
	return stat.size;
}


function CLParams(argv) {
	this.unnamedParameters=[];
	this.namedParameters={};

	var args=argv.slice(2);
	for (var i=0; i<args.length; i++) {
		var arg0=args[i];
		if (arg0.indexOf('--')===0) {
			arg0=arg0.slice(2);
			var ind=arg0.indexOf('=');
			if (ind>=0) {
				this.namedParameters[arg0.slice(0,ind)]=arg0.slice(ind+1);
			}
			else {
				//this.namedParameters[arg0]=args[i+1]||'';
				//i++;
				this.namedParameters[arg0]='';
			}
		}
		else if (arg0.indexOf('-')===0) {
			arg0=arg0.slice(1);
			this.namedParameters[arg0]='';
		}
		else {
			this.unnamedParameters.push(arg0);
		}
	}
};

function format_file_size(size_bytes) {
	size_bytes=Number(size_bytes);
	if (size_bytes>10e9) {
	  return Math.floor(size_bytes/1e9)+' GB';
	}
	else if (size_bytes>1e9) {
	  return Math.floor(size_bytes/1e8)/10+' GB';  
	}
	else if (size_bytes>10e6) {
	  return Math.floor(size_bytes/1e6)+' MB';
	}
	else if (size_bytes>1e6) {
	  return Math.floor(size_bytes/1e5)/10+' MB';  
	}
	else if (size_bytes>10e3) {
	  return Math.floor(size_bytes/1e3)+' KB';
	}
	else if (size_bytes>1e3) {
	  return Math.floor(size_bytes/1e2)/10+' KB';  
	}
	else {
	  return size_bytes+' bytes';
	}
}

function foreach(array,opts,step_function,end_function) {
	var num_parallel=opts.num_parallel||1;
	var num_running=0;
	var num_finished=0;
	var already_called_end=false;
	var ii=0;
	next_step();
	function next_step() {
		if (num_finished>=array.length) {
			setTimeout(function() { //important to do it this way so we don't accumulate a call stack
				if (!already_called_end) { 
					already_called_end=true;
					end_function();
				}
			},0);
			return;
		}
		while ((ii<array.length)&&(num_running<num_parallel)) {
			num_running++;
			ii++;
			step_function(ii-1,array[ii-1],function() {
				num_running--;
				num_finished++;
				setTimeout(function() { //important to do it this way so we don't accumulate a call stack
					next_step();
				},0);
			});
		}
	}
}


function mkdir_if_needed(path) {
	var fs=require('fs');
	if (!fs.existsSync(path)){
    	fs.mkdirSync(path);
	}
}

function remove_parts_files(parts_dirname) {
	var files = require('fs').readdirSync(parts_dirname);
	for (var i in files) {
		if (files[i].startsWith('part.'))
			require('fs').unlinkSync(parts_dirname+'/'+files[i]);
	}
}